<!-- MFA Modal -->
<div id="mfa-modal" class="mfa-modal hidden" aria-hidden="true">
  <div class="mfa-backdrop"></div>
  <div class="mfa-dialog" role="dialog" aria-modal="true" aria-labelledby="mfa-title">
    <h2 id="mfa-title">추가 인증</h2>
    <p class="mfa-desc">인증앱의 6자리 코드 또는 백업코드를 입력하세요.</p>

    <form id="mfa-form">
      <input type="text" id="mfa-code" inputmode="numeric" autocomplete="one-time-code"
             placeholder="6자리 코드 또는 백업코드" maxlength="16" required />
      <div class="mfa-actions">
        <button type="submit" id="mfa-submit">인증</button>
        <button type="button" id="mfa-cancel">취소</button>
      </div>
      <p id="mfa-error" class="mfa-error" role="alert" style="display:none;"></p>
    </form>
  </div>
</div>

<style>
  .mfa-modal.hidden{display:none}
  .mfa-modal{position:fixed;inset:0;z-index:9999}
  .mfa-backdrop{position:absolute;inset:0;background:rgba(0,0,0,.35)}
  .mfa-dialog{position:relative;margin:10vh auto 0;max-width:360px;background:#fff;border-radius:12px;padding:20px;box-shadow:0 10px 30px rgba(0,0,0,.2)}
  #mfa-code{width:100%;font-size:18px;padding:10px 12px;border:1px solid #ddd;border-radius:8px}
  .mfa-actions{display:flex;gap:8px;justify-content:flex-end;margin-top:12px}
  .mfa-actions button{padding:8px 12px;border-radius:8px;border:0;cursor:pointer}
  #mfa-submit{background:#111;color:#fff}
  #mfa-cancel{background:#eee}
  .mfa-error{color:#c00;margin-top:8px}
</style>

<script>
  (() => {
    const MODAL = document.getElementById('mfa-modal');
    const FORM  = document.getElementById('mfa-form');
    const INPUT = document.getElementById('mfa-code');
    const ERR   = document.getElementById('mfa-error');
    const BTN_CANCEL = document.getElementById('mfa-cancel');

    let pendingRetry = null; // () => Promise<Response>

    function openModal(reason) {
      ERR.style.display = 'none';
      ERR.textContent = '';
      INPUT.value = '';
      MODAL.classList.remove('hidden');
      MODAL.setAttribute('aria-hidden', 'false');
      setTimeout(() => INPUT.focus(), 0);
    }
    function closeModal() {
      MODAL.classList.add('hidden');
      MODAL.setAttribute('aria-hidden', 'true');
    }

    async function verifyMfa(code) {
      // 백엔드 verify 엔드포인트 (본문은 간단히 문자열/DTO 둘 다 대응)
      const res = await fetch('/api/mfa/totp/verify', {
        method: 'POST',
        headers: {'Content-Type':'application/json','X-Requested-With':'XMLHttpRequest'},
        body: JSON.stringify(code)
      });
      if (!res.ok) return false;
      const txt = await res.text();
      return txt.trim().toUpperCase() === 'OK';
    }

    FORM.addEventListener('submit', async (e) => {
      e.preventDefault();
      const code = INPUT.value.trim();
      if (!code) return;

      const ok = await verifyMfa(code);
      if (!ok) {
        ERR.textContent = '인증에 실패했습니다. 코드를 확인해 주세요.';
        ERR.style.display = 'block';
        INPUT.select();
        return;
      }
      closeModal();

      if (pendingRetry) {
        // 원요청 재시도
        try {
          const resp = await pendingRetry();
          window.dispatchEvent(new CustomEvent('mfa:retried', {detail:{ok:true}}));
          // 재시도 응답 소비는 호출자가 하므로 여기선 아무 것도 안함
        } finally {
          pendingRetry = null;
        }
      }
    });

    BTN_CANCEL.addEventListener('click', () => {
      pendingRetry = null;
      closeModal();
    });

    /**
     * fetchWithMfa: 401 + X-MFA-Required 감지 시 모달로 TOTP 받고 재시도
     * @param {() => Promise<Response>} doRequest - 실제 요청을 수행하는 함수(재시도 가능해야 함)
     * @returns {Promise<Response>}
     *
     * 사용 예:
     *   const res = await fetchWithMfa(() => fetch('/api/payments/transfer', {method:'POST', ...}));
     */
    async function fetchWithMfa(doRequest) {
      const res = await doRequest();
      if (res.status !== 401) return res;

      const need = res.headers.get('X-MFA-Required');
      if (need && need.toUpperCase() === 'TOTP') {
        const reason = res.headers.get('X-MFA-Reason') || '';
        pendingRetry = doRequest; // 원요청 저장
        openModal(reason);
        // 모달 종료/검증 후 재시도 응답을 사용하고 싶다면,
        // 호출 측에서 'mfa:retried' 이벤트를 듣거나, 여기서 Promise를 분기 처리해도 됨.
        // 간단히는 호출부에서 두 번째로 fetchWithMfa를 다시 호출.
      }
      return res; // 최초 응답 반환(호출부에서 상태 보고 분기)
    }

    // 전역 노출
    window.fetchWithMfa = fetchWithMfa;
  })();
</script>
